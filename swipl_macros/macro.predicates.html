<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Define foreign predicates written in rust for use in prolog."><title>predicates in swipl_macros - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="swipl_macros" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.1 (d5c2e9c34 2023-09-13)" data-channel="1.72.1" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc macro"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../swipl_macros/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../swipl_macros/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><div class="sidebar-elems"><h2><a href="index.html">In swipl_macros</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Macro <a href="index.html">swipl_macros</a>::<wbr><a class="macro" href="#">predicates</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/swipl_macros/lib.rs.html#231-233">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>predicates!() { /* proc-macro */ }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Define foreign predicates written in rust for use in prolog.</p>
<p>The <code>predicates!</code> macro takes an arbitrary amount of predicate
definitions. These definitions may be semidet or
nondet. Optionally, a visibility specifier like <code>pub</code> may be used
to change the visibility of the generated functions. These
definitions look somewhat like ordinary rust functions. However,
their argument list is completely untyped, as each argument is
known to be a <code>&amp;Term</code>, except for the first argument which is a
context object. As there always needs to be a context to call a
predicate, this first argument is required, even if it is unused.</p>
<p>For each definition, a registration function will be
generated. This function will be named <code>register_&lt;name&gt;</code>, where
name is the name of the defined predicate, and this function will
take zero arguments. After calling this function, the predicate is
registered and may be used from prolog code.</p>
<p>Each definition may optionally be annotated with
<code>#[module(&quot;&lt;module&gt;&quot;)]</code> and/or <code>#[name(&quot;&lt;name&gt;&quot;)]</code> To change the
module this predicate will be registered in, or the name of the
predicate in prolog. By default, the predicate name will be the
definition name, and the module will be the context module at the
time of generation. For foreign libraries, this context module is
whatever module did the first import of this library. Otherwise
it’s usually ‘user’.</p>
<h2 id="semideterministic-predicates"><a href="#semideterministic-predicates">Semideterministic predicates</a></h2>
<p>The first kind of predicate that you can define is a semidet
predicate. Semidet, or semideterministic, means that this
predicate is only going to have one result, and it could either be
success or failure. Note that this also covers the deterministic
case - to implement a deterministic predicate, just ensure that
your predicate does not fail.</p>
<p>Semidet predicates return a <code>PrologResult&lt;()&gt;</code>, which also happens
to be the type returned by most of the functions in the <code>swipl</code>
library. This means you can easily handle failure and exception of
things you call using rust’s <code>?</code> syntax, or make use of the various combinators that are defined on <code>context</code> objects and in the <code>result</code> module.</p>
<h3 id="examples"><a href="#examples">Examples</a></h3>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="macro">predicates! </span>{
    semidet <span class="kw">fn </span>unify_with_foo(context, term) {
        <span class="kw">let </span>atom = context.new_atom(<span class="string">&quot;foo&quot;</span>);
        term.unify(<span class="kw-2">&amp;</span>atom)
    }

    <span class="attr">#[module(<span class="string">&quot;some_module&quot;</span>)]
    #[name(<span class="string">&quot;some_alternate_name&quot;</span>)]
    </span><span class="kw">pub </span>semidet <span class="kw">fn </span>term_is_42(_context, term) {
        <span class="kw">let </span>num: u64 = term.get::&lt;u64&gt;()<span class="question-mark">?</span>;

        into_prolog_result(num == <span class="number">42</span>)
    }

    semidet <span class="kw">fn </span>just_fail(_context) {
        <span class="prelude-val">Err</span>(PrologError::Failure)
    }

    <span class="kw">pub </span>semidet <span class="kw">fn </span>throw_if_not_42(_context, term) {
        <span class="kw">let </span>num: u64 = term.get::&lt;u64&gt;()<span class="question-mark">?</span>;
        <span class="kw">if </span>num != <span class="number">42 </span>{
            context.raise_exception(<span class="kw-2">&amp;</span><span class="macro">term!</span>{context: error(this_is_not_the_answer, <span class="kw">_</span>)})
        } <span class="kw">else </span>{
            <span class="prelude-val">Ok</span>(())
        }
    }
}</code></pre></div>
<p>To register these defined predicates, their register function has to be called:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>register_unify_with_foo();
register_term_is_42();
register_just_fail();
register_throw_if_not_42();</code></pre></div>
<h2 id="nondeterministic-predicates"><a href="#nondeterministic-predicates">Nondeterministic predicates</a></h2>
<p>Nondet or nondeterministic predicates are a bit more complex to
implement. Instead of just one block which returns success or
failure, nondet predicates are implemented with two bodies, a
setup block and a call block.</p>
<p>In the setup block, you create a state object which will be
available in the call block. The call block is then called with
this state object. As long as the call block returns true, the
predicate call is considered to still have choice points and will
be called unless the caller does a cut, which will clean up the
state object automatically.</p>
<h3 id="the-state-type"><a href="#the-state-type">The state type</a></h3>
<p>Nondeterministic predicate definitions require you to specify a
type argument as part of the function signature. This specifies
the type of the state object, and is required to implement the
auto-traits <code>Send</code> and <code>Unpin</code>.</p>
<h3 id="setup"><a href="#setup">Setup</a></h3>
<p>The setup block is called at the start of a predicate
invocation. It is to return a <code>PrologResult&lt;Option&lt;StateObject&gt;&gt;</code>,
where <code>StateObject</code> is your state object type.</p>
<p>You can return from this block in three ways:</p>
<ul>
<li>Return an exception or failure. The predicate will error or fail accordingly and the call block will not be invoked.</li>
<li>Return <code>None</code>. The call block will also not be invoked, but the
predicate will return success. This is useful to handle predicate
inputs which allow your predicate to behave in a semidet manner.</li>
<li>Return <code>Some(object)</code>. This returns a state object for use in
the call block. After this, the call block will be invoked.</li>
</ul>
<h3 id="call"><a href="#call">Call</a></h3>
<p>The call block is called each time the next result is required from this predicate. This happens on the first call to this predicate (except if the setup returned early as described above), and subsequently upon backtracking. The call block is given a mutable borrow of the state object, and is therefore able to both inspect and modify it.</p>
<p>you can return from this block in three ways:</p>
<ul>
<li>Return an exception or failure. Thep redicate will error or fail accordingly, and the call block will not be invoked again.</li>
<li>Return false, signaling that this was the last succesful call to this predicate.</li>
<li>Return true, signaling that there’s more results available upon backtracking.</li>
</ul>
<p>After exception, failure or returning false to signal the last succesful call, the state object will be cleaned up automatically.</p>
<h3 id="examples-1"><a href="#examples-1">Examples</a></h3>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="macro">predicates!</span>{
    nondet <span class="kw">fn </span>unify_with_bar_baz&lt;Vec&lt;String&gt;&gt;(context, term) {
        setup =&gt; {
            <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(<span class="macro">vec!</span>[<span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>]))
        },
        call(v) =&gt; {
            <span class="kw">let </span>next = v.pop().unwrap();
            <span class="kw">let </span>atom = context.new_atom(next);
            term.unify(<span class="kw-2">&amp;</span>atom)<span class="question-mark">?</span>;

            <span class="prelude-val">Ok</span>(!v.is_empty())
        }
    }

    nondet <span class="kw">fn </span>fail_early&lt;()&gt;(_context) {
        setup =&gt; {
            <span class="prelude-val">Err</span>(PrologError::Failure)
        },
        call(<span class="kw">_</span>) =&gt; {
            <span class="comment">// We never get here
        </span>}
    }

    nondet <span class="kw">fn </span>succeed_early&lt;()&gt;(_context) {
        setup =&gt; {
            <span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>)
        },
        call(<span class="kw">_</span>) =&gt; {
            <span class="comment">// We never get here
        </span>}
    }
}</code></pre></div>
</div></details></section></div></main></body></html>