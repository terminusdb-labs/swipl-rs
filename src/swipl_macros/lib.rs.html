<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `swipl-macros/src/lib.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>lib.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../swipl_macros/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../swipl_macros/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../swipl_macros/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
</pre><pre class="rust"><code><span class="doccomment">//! swipl-macros provides procedural macros for the swipl crate.</span>
<span class="attribute">#![<span class="ident">doc</span>(<span class="ident">html_root_url</span> <span class="op">=</span> <span class="string">&quot;https://terminusdb-labs.github.io/swipl-rs/swipl_macros/&quot;</span>)]</span>

<span class="kw">mod</span> <span class="ident">kw</span>;
<span class="kw">mod</span> <span class="ident">util</span>;

<span class="kw">mod</span> <span class="ident">atom</span>;
<span class="kw">mod</span> <span class="ident">blob</span>;
<span class="kw">mod</span> <span class="ident">functor</span>;
<span class="kw">mod</span> <span class="ident">pred</span>;
<span class="kw">mod</span> <span class="ident">predicate</span>;
<span class="kw">mod</span> <span class="ident">prolog</span>;
<span class="kw">mod</span> <span class="ident">term</span>;

<span class="kw">use</span> <span class="ident">proc_macro::TokenStream</span>;

<span class="doccomment">/// Define prolog predicates to be used from rust code.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The `prolog!` macro takes a block of function declaration. Each</span>
<span class="doccomment">/// declaration is of the format `fn &lt;predicate&gt;(..args..);`, where</span>
<span class="doccomment">/// args is a list of argument names. Optionally, a visibility</span>
<span class="doccomment">/// specifier like `pub` may be used. This much like an ordinary rust</span>
<span class="doccomment">/// function declaration, except that the arguments are typeless.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Each function may be annotated with a `#[name(&quot;..name..&quot;)]`</span>
<span class="doccomment">/// attribute, which specifies what the name of this predicate is in</span>
<span class="doccomment">/// prolog. When omitted, the function name will be used.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Each function may be annotated with a `#[module(&quot;..module..&quot;)]`</span>
<span class="doccomment">/// attribute, which specifies what prolog module this predicate is</span>
<span class="doccomment">/// in.  When omitted, no module is assumed.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// For each function declaration, a function will be generated which</span>
<span class="doccomment">/// takes a context argument, followed by all declared arguments, and</span>
<span class="doccomment">/// returns a query opened in that context.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Example:</span>
<span class="doccomment">/// ```ignore</span>
<span class="doccomment">/// prolog! {</span>
<span class="doccomment">///     fn writeq(term);</span>
<span class="doccomment">///     #[name(&quot;nl&quot;)]</span>
<span class="doccomment">///     fn print_a_newline();</span>
<span class="doccomment">///     #[module(&quot;zlib&quot;)]</span>
<span class="doccomment">///     pub fn zopen(stream, zstream, options);</span>
<span class="doccomment">/// }</span>
<span class="doccomment">/// ```</span>
<span class="attribute">#[<span class="ident">proc_macro</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">prolog</span>(<span class="ident">stream</span>: <span class="ident">TokenStream</span>) -&gt; <span class="ident">TokenStream</span> {
    <span class="ident">prolog::prolog_macro</span>(<span class="ident">stream</span>).<span class="ident">into</span>()
}

<span class="doccomment">/// Generate an inline callable predicate.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Predicates are specified in prolog style. You can either use the</span>
<span class="doccomment">/// syntax `predicate/arity` or `module:predicate/arity`.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This macro will generate code that generates a `CallablePredicate`</span>
<span class="doccomment">/// object. The actual prolog predicate is only looked up at first</span>
<span class="doccomment">/// call of this generated code. Each subsequent call will reuse the</span>
<span class="doccomment">/// lookup.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// example:</span>
<span class="doccomment">/// ```ignore</span>
<span class="doccomment">/// let writeq = pred!(writeq/1);</span>
<span class="doccomment">/// context.call_once(writeq, [&amp;term])?;</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">/// ```ignore</span>
<span class="doccomment">/// context.call_once(pred!(user:nl/0), [])?;</span>
<span class="doccomment">/// ```</span>
<span class="attribute">#[<span class="ident">proc_macro</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">pred</span>(<span class="ident">stream</span>: <span class="ident">TokenStream</span>) -&gt; <span class="ident">TokenStream</span> {
    <span class="ident">pred::pred_macro</span>(<span class="ident">stream</span>).<span class="ident">into</span>()
}

<span class="doccomment">/// Define foreign predicates written in rust for use in prolog.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The `predicates!` macro takes an arbitrary amount of predicate</span>
<span class="doccomment">/// definitions. These definitions may be semidet or</span>
<span class="doccomment">/// nondet. Optionally, a visibility specifier like `pub` may be used</span>
<span class="doccomment">/// to change the visibility of the generated functions. These</span>
<span class="doccomment">/// definitions look somewhat like ordinary rust functions. However,</span>
<span class="doccomment">/// their argument list is completely untyped, as each argument is</span>
<span class="doccomment">/// known to be a `&amp;Term`, except for the first argument which is a</span>
<span class="doccomment">/// context object. As there always needs to be a context to call a</span>
<span class="doccomment">/// predicate, this first argument is required, even if it is unused.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// For each definition, a registration function will be</span>
<span class="doccomment">/// generated. This function will be named `register_&lt;name&gt;`, where</span>
<span class="doccomment">/// name is the name of the defined predicate, and this function will</span>
<span class="doccomment">/// take zero arguments. After calling this function, the predicate is</span>
<span class="doccomment">/// registered and may be used from prolog code.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Each definition may optionally be annotated with</span>
<span class="doccomment">/// `#[module(&quot;&lt;module&gt;&quot;)]` and/or `#[name(&quot;&lt;name&gt;&quot;)]` To change the</span>
<span class="doccomment">/// module this predicate will be registered in, or the name of the</span>
<span class="doccomment">/// predicate in prolog. By default, the predicate name will be the</span>
<span class="doccomment">/// definition name, and the module will be the context module at the</span>
<span class="doccomment">/// time of generation. For foreign libraries, this context module is</span>
<span class="doccomment">/// whatever module did the first import of this library. Otherwise</span>
<span class="doccomment">/// it&#39;s usually &#39;user&#39;.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Semideterministic predicates</span>
<span class="doccomment">/// The first kind of predicate that you can define is a semidet</span>
<span class="doccomment">/// predicate. Semidet, or semideterministic, means that this</span>
<span class="doccomment">/// predicate is only going to have one result, and it could either be</span>
<span class="doccomment">/// success or failure. Note that this also covers the deterministic</span>
<span class="doccomment">/// case - to implement a deterministic predicate, just ensure that</span>
<span class="doccomment">/// your predicate does not fail.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Semidet predicates return a `PrologResult&lt;()&gt;`, which also happens</span>
<span class="doccomment">/// to be the type returned by most of the functions in the `swipl`</span>
<span class="doccomment">/// library. This means you can easily handle failure and exception of</span>
<span class="doccomment">/// things you call using rust&#39;s `?` syntax, or make use of the various combinators that are defined on `context` objects and in the `result` module.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ## Examples</span>
<span class="doccomment">/// ```ignore</span>
<span class="doccomment">/// predicates! {</span>
<span class="doccomment">///     semidet fn unify_with_foo(context, term) {</span>
<span class="doccomment">///         let atom = context.new_atom(&quot;foo&quot;);</span>
<span class="doccomment">///         term.unify(&amp;atom)</span>
<span class="doccomment">///     }</span>
<span class="doccomment">///</span>
<span class="doccomment">///     #[module(&quot;some_module&quot;)]</span>
<span class="doccomment">///     #[name(&quot;some_alternate_name&quot;)]</span>
<span class="doccomment">///     pub semidet fn term_is_42(_context, term) {</span>
<span class="doccomment">///         let num: u64 = term.get::&lt;u64&gt;()?;</span>
<span class="doccomment">///</span>
<span class="doccomment">///         into_prolog_result(num == 42)</span>
<span class="doccomment">///     }</span>
<span class="doccomment">///</span>
<span class="doccomment">///     semidet fn just_fail(_context) {</span>
<span class="doccomment">///         Err(PrologError::Failure)</span>
<span class="doccomment">///     }</span>
<span class="doccomment">///</span>
<span class="doccomment">///     pub semidet fn throw_if_not_42(_context, term) {</span>
<span class="doccomment">///         let num: u64 = term.get::&lt;u64&gt;()?;</span>
<span class="doccomment">///         if num != 42 {</span>
<span class="doccomment">///             context.raise_exception(&amp;term!{context: error(this_is_not_the_answer, _)})</span>
<span class="doccomment">///         } else {</span>
<span class="doccomment">///             Ok(())</span>
<span class="doccomment">///         }</span>
<span class="doccomment">///     }</span>
<span class="doccomment">/// }</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">/// To register these defined predicates, their register function has to be called:</span>
<span class="doccomment">/// ```ignore</span>
<span class="doccomment">/// register_unify_with_foo();</span>
<span class="doccomment">/// register_term_is_42();</span>
<span class="doccomment">/// register_just_fail();</span>
<span class="doccomment">/// register_throw_if_not_42();</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Nondeterministic predicates</span>
<span class="doccomment">/// Nondet or nondeterministic predicates are a bit more complex to</span>
<span class="doccomment">/// implement. Instead of just one block which returns success or</span>
<span class="doccomment">/// failure, nondet predicates are implemented with two bodies, a</span>
<span class="doccomment">/// setup block and a call block.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// In the setup block, you create a state object which will be</span>
<span class="doccomment">/// available in the call block. The call block is then called with</span>
<span class="doccomment">/// this state object. As long as the call block returns true, the</span>
<span class="doccomment">/// predicate call is considered to still have choice points and will</span>
<span class="doccomment">/// be called unless the caller does a cut, which will clean up the</span>
<span class="doccomment">/// state object automatically.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ## The state type</span>
<span class="doccomment">/// Nondeterministic predicate definitions require you to specify a</span>
<span class="doccomment">/// type argument as part of the function signature. This specifies</span>
<span class="doccomment">/// the type of the state object, and is required to implement the</span>
<span class="doccomment">/// auto-traits `Send` and `Unpin`.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ## Setup</span>
<span class="doccomment">/// The setup block is called at the start of a predicate</span>
<span class="doccomment">/// invocation. It is to return a `PrologResult&lt;Option&lt;StateObject&gt;&gt;`,</span>
<span class="doccomment">/// where `StateObject` is your state object type.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// You can return from this block in three ways:</span>
<span class="doccomment">/// - Return an exception or failure. The predicate will error or fail accordingly and the call block will not be invoked.</span>
<span class="doccomment">/// - Return `None`. The call block will also not be invoked, but the</span>
<span class="doccomment">/// predicate will return success. This is useful to handle predicate</span>
<span class="doccomment">/// inputs which allow your predicate to behave in a semidet manner.</span>
<span class="doccomment">/// - Return `Some(object)`. This returns a state object for use in</span>
<span class="doccomment">/// the call block. After this, the call block will be invoked.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ## Call</span>
<span class="doccomment">/// The call block is called each time the next result is required from this predicate. This happens on the first call to this predicate (except if the setup returned early as described above), and subsequently upon backtracking. The call block is given a mutable borrow of the state object, and is therefore able to both inspect and modify it.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// you can return from this block in three ways:</span>
<span class="doccomment">/// - Return an exception or failure. Thep redicate will error or fail accordingly, and the call block will not be invoked again.</span>
<span class="doccomment">/// - Return false, signaling that this was the last succesful call to this predicate.</span>
<span class="doccomment">/// - Return true, signaling that there&#39;s more results available upon backtracking.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// After exception, failure or returning false to signal the last succesful call, the state object will be cleaned up automatically.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ## Examples</span>
<span class="doccomment">/// ```ignore</span>
<span class="doccomment">/// predicates!{</span>
<span class="doccomment">///     nondet fn unify_with_bar_baz&lt;Vec&lt;String&gt;&gt;(context, term) {</span>
<span class="doccomment">///         setup =&gt; {</span>
<span class="doccomment">///             Ok(Some(vec![&quot;bar&quot;, &quot;baz&quot;]))</span>
<span class="doccomment">///         },</span>
<span class="doccomment">///         call(v) =&gt; {</span>
<span class="doccomment">///             let next = v.pop().unwrap();</span>
<span class="doccomment">///             let atom = context.new_atom(next);</span>
<span class="doccomment">///             term.unify(&amp;atom)?;</span>
<span class="doccomment">///</span>
<span class="doccomment">///             Ok(!v.is_empty())</span>
<span class="doccomment">///         }</span>
<span class="doccomment">///     }</span>
<span class="doccomment">///</span>
<span class="doccomment">///     nondet fn fail_early&lt;()&gt;(_context) {</span>
<span class="doccomment">///         setup =&gt; {</span>
<span class="doccomment">///             Err(PrologError::Failure)</span>
<span class="doccomment">///         },</span>
<span class="doccomment">///         call(_) =&gt; {</span>
<span class="doccomment">///             // We never get here</span>
<span class="doccomment">///         }</span>
<span class="doccomment">///     }</span>
<span class="doccomment">///</span>
<span class="doccomment">///     nondet fn succeed_early&lt;()&gt;(_context) {</span>
<span class="doccomment">///         setup =&gt; {</span>
<span class="doccomment">///             Ok(None)</span>
<span class="doccomment">///         },</span>
<span class="doccomment">///         call(_) =&gt; {</span>
<span class="doccomment">///             // We never get here</span>
<span class="doccomment">///         }</span>
<span class="doccomment">///     }</span>
<span class="doccomment">/// }</span>
<span class="doccomment">/// ```</span>
<span class="attribute">#[<span class="ident">proc_macro</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">predicates</span>(<span class="ident">stream</span>: <span class="ident">TokenStream</span>) -&gt; <span class="ident">TokenStream</span> {
    <span class="ident">predicate::predicates_macro</span>(<span class="ident">stream</span>).<span class="ident">into</span>()
}

<span class="doccomment">/// Generate a term from a rust expression.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This macro takes two arguments, a context to generate the term in,</span>
<span class="doccomment">/// and a rust expression representing the prolog term to generate..</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The macro returns a `PrologResult&lt;Term&gt;` containing new term,</span>
<span class="doccomment">/// created through `context.new_term_ref()`, which contains a prolog</span>
<span class="doccomment">/// term corresponding to the description. The `term!` macro cannot</span>
<span class="doccomment">/// actually fail with a PrologFailure, but it is possible for a</span>
<span class="doccomment">/// resource limit exception to be triggered by one of the underlying</span>
<span class="doccomment">/// calls into prolog.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Examples</span>
<span class="doccomment">/// Generate a nested functor term:</span>
<span class="doccomment">/// ```ignore</span>
<span class="doccomment">/// let term = term!{context: foo(bar(baz, quux))}?;</span>
<span class="doccomment">///```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Embed a value in the term:</span>
<span class="doccomment">/// ```ignore</span>
<span class="doccomment">/// let num = 42;</span>
<span class="doccomment">/// let term = term!{context: foo(#42)}?;</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Embed a term in the term:</span>
<span class="doccomment">/// ```ignore</span>
<span class="doccomment">/// let inner = context.new_term_ref();</span>
<span class="doccomment">/// let term = term!{context: foo(#&amp;inner)}?;</span>
<span class="doccomment">/// ```</span>
<span class="attribute">#[<span class="ident">proc_macro</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">term</span>(<span class="ident">stream</span>: <span class="ident">TokenStream</span>) -&gt; <span class="ident">TokenStream</span> {
    <span class="ident">term::term_macro</span>(<span class="ident">stream</span>).<span class="ident">into</span>()
}

<span class="doccomment">/// Define an arc blob.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// See the [swipl::blob](https://terminusdb-labs.github.io/swipl-rs/swipl/blob/index.html) module documentation for more details.</span>
<span class="attribute">#[<span class="ident">proc_macro_attribute</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">arc_blob</span>(<span class="ident">attr</span>: <span class="ident">TokenStream</span>, <span class="ident">item</span>: <span class="ident">TokenStream</span>) -&gt; <span class="ident">TokenStream</span> {
    <span class="ident">blob::arc_blob_macro</span>(<span class="ident">attr</span>, <span class="ident">item</span>)
}

<span class="doccomment">/// Define a wrapped arc blob.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// See the [swipl::blob](https://terminusdb-labs.github.io/swipl-rs/swipl/blob/index.html) module documentation for more details.</span>
<span class="attribute">#[<span class="ident">proc_macro</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">wrapped_arc_blob</span>(<span class="ident">item</span>: <span class="ident">TokenStream</span>) -&gt; <span class="ident">TokenStream</span> {
    <span class="ident">blob::wrapped_arc_blob_macro</span>(<span class="ident">item</span>)
}

<span class="doccomment">/// Define a clone blob.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// See the [swipl::blob](https://terminusdb-labs.github.io/swipl-rs/swipl/blob/index.html) module documentation for more details.</span>
<span class="attribute">#[<span class="ident">proc_macro_attribute</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">clone_blob</span>(<span class="ident">attr</span>: <span class="ident">TokenStream</span>, <span class="ident">item</span>: <span class="ident">TokenStream</span>) -&gt; <span class="ident">TokenStream</span> {
    <span class="ident">blob::clone_blob_macro</span>(<span class="ident">attr</span>, <span class="ident">item</span>)
}

<span class="doccomment">/// Define a wrapped clone blob.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// See the [swipl::blob](https://terminusdb-labs.github.io/swipl-rs/swipl/blob/index.html) module documentation for more details.</span>
<span class="attribute">#[<span class="ident">proc_macro</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">wrapped_clone_blob</span>(<span class="ident">item</span>: <span class="ident">TokenStream</span>) -&gt; <span class="ident">TokenStream</span> {
    <span class="ident">blob::wrapped_clone_blob_macro</span>(<span class="ident">item</span>)
}

<span class="doccomment">/// Create a static atom.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The atom will only actually be created on first invocation. Each</span>
<span class="doccomment">/// subsequent invocation will reuse the earlier retrieved atom. This</span>
<span class="doccomment">/// is convenient for code that uses the exact same atom on repeated</span>
<span class="doccomment">/// invocations.</span>
<span class="attribute">#[<span class="ident">proc_macro</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">atom</span>(<span class="ident">item</span>: <span class="ident">TokenStream</span>) -&gt; <span class="ident">TokenStream</span> {
    <span class="ident">atom::atom_macro</span>(<span class="ident">item</span>)
}

<span class="doccomment">/// Create a static functor.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The functor will only actually be created on first</span>
<span class="doccomment">/// invocation. Each subsequent invocation will reuse the earlier</span>
<span class="doccomment">/// retrieved functor. This is convenient for code that uses the exact</span>
<span class="doccomment">/// same functor on repeated invocations.</span>
<span class="attribute">#[<span class="ident">proc_macro</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">functor</span>(<span class="ident">item</span>: <span class="ident">TokenStream</span>) -&gt; <span class="ident">TokenStream</span> {
    <span class="ident">functor::functor_macro</span>(<span class="ident">item</span>)
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="swipl_macros" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.64.0 (a55dd71d5 2022-09-19)" ></div></body></html>