(function() {var type_impls = {
"swipl":[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Context%3C'a,+C%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/swipl/callable.rs.html#195-242\">source</a><a href=\"#impl-Context%3C'a,+C%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, C: <a class=\"trait\" href=\"swipl/callable/trait.OpenCall.html\" title=\"trait swipl::callable::OpenCall\">OpenCall</a>&gt; <a class=\"struct\" href=\"swipl/context/struct.Context.html\" title=\"struct swipl::context::Context\">Context</a>&lt;'a, C&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.next_solution\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/callable.rs.html#202-204\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.next_solution\" class=\"fn\">next_solution</a>(&amp;self) -&gt; <a class=\"type\" href=\"swipl/result/type.PrologResult.html\" title=\"type swipl::result::PrologResult\">PrologResult</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.bool.html\">bool</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieve the next solution.</p>\n<p>If solution retrieval led to a failure or an error, this is\nreturned in the <code>Err</code> part of the <code>PrologResult</code>. Otherwise,\n<code>Ok(true)</code> is returned if there are more solutions, and\n<code>Ok(false)</code> is returned when this is the last solution.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.cut\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/callable.rs.html#210-212\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.cut\" class=\"fn\">cut</a>(self)</h4></section></summary><div class=\"docblock\"><p>Cut the query, keeping all data it has created.</p>\n<p>Any unifications the query did to terms from parent contexts\nwill be retained.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.discard\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/callable.rs.html#218-220\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.discard\" class=\"fn\">discard</a>(self)</h4></section></summary><div class=\"docblock\"><p>Discard the query, discarding all data it has created.</p>\n<p>Any unifications the query did to terms from parent contexts\nwill be discarded.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.once\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/callable.rs.html#223-228\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.once\" class=\"fn\">once</a>(self) -&gt; <a class=\"type\" href=\"swipl/result/type.PrologResult.html\" title=\"type swipl::result::PrologResult\">PrologResult</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieve one result, and then cut.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ignore\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/callable.rs.html#233-241\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.ignore\" class=\"fn\">ignore</a>(self) -&gt; <a class=\"type\" href=\"swipl/result/type.PrologResult.html\" title=\"type swipl::result::PrologResult\">PrologResult</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieve one result, ignoring failures, and then cut.</p>\n<p>Exceptions will still be returned as such.</p>\n</div></details></div></details>",0,"swipl::context::GenericQueryableContext"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Context%3C'a,+T%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#153-330\">source</a><a href=\"#impl-Context%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T: <a class=\"trait\" href=\"swipl/context/trait.ContextType.html\" title=\"trait swipl::context::ContextType\">ContextType</a>&gt; <a class=\"struct\" href=\"swipl/context/struct.Context.html\" title=\"struct swipl::context::Context\">Context</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.assert_activated\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#183-187\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.assert_activated\" class=\"fn\">assert_activated</a>(&amp;self)</h4></section></summary><div class=\"docblock\"><p>Panics if this context is not active.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.assert_no_exception\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#190-194\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.assert_no_exception\" class=\"fn\">assert_no_exception</a>(&amp;self)</h4></section></summary><div class=\"docblock\"><p>Panics if the engine is in an exceptional state.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.engine_ptr\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#197-199\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.engine_ptr\" class=\"fn\">engine_ptr</a>(&amp;self) -&gt; <a class=\"type\" href=\"swipl/fli/type.PL_engine_t.html\" title=\"type swipl::fli::PL_engine_t\">PL_engine_t</a></h4></section></summary><div class=\"docblock\"><p>Returns the underlying engine pointer.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.wrap_term_ref\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#213-216\">source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"swipl/context/struct.Context.html#tymethod.wrap_term_ref\" class=\"fn\">wrap_term_ref</a>(&amp;self, term: <a class=\"type\" href=\"swipl/fli/type.term_t.html\" title=\"type swipl::fli::term_t\">term_t</a>) -&gt; <a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;</h4></section></summary><div class=\"docblock\"><p>Wrap the given term_t into a Term with a lifetime corresponding to this context.</p>\n<h5 id=\"safety\"><a href=\"#safety\">Safety</a></h5>\n<p>This is unsafe because there’s no way of checking that the\ngiven term_t is indeed from this context. The caller will have\nto ensure that the term lives at least as long as this\ncontext.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.has_exception\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#219-223\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.has_exception\" class=\"fn\">has_exception</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns true if the underlying engine is in an exceptional state.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clear_exception\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#226-231\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.clear_exception\" class=\"fn\">clear_exception</a>(&amp;self)</h4></section></summary><div class=\"docblock\"><p>Clear the current exception if there is any.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.with_uncleared_exception\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#238-262\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.with_uncleared_exception\" class=\"fn\">with_uncleared_exception</a>&lt;'b, R&gt;(\n    &amp;'b self,\n    f: impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.76.0/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>(<a class=\"enum\" href=\"https://doc.rust-lang.org/1.76.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"swipl/context/struct.ExceptionTerm.html\" title=\"struct swipl::context::ExceptionTerm\">ExceptionTerm</a>&lt;'b&gt;&gt;) -&gt; R\n) -&gt; R</h4></section></summary><div class=\"docblock\"><p>Call the given function with the exception term, if it exists.</p>\n<p>The given function is able to clear the exception term, but\nnot much else is allowed from safe code. Any attempt to do a\nget, put or unify with the given term will result in a panic.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.with_exception\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#270-275\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.with_exception\" class=\"fn\">with_exception</a>&lt;R&gt;(&amp;self, f: impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.76.0/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>(<a class=\"enum\" href=\"https://doc.rust-lang.org/1.76.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;&gt;) -&gt; R) -&gt; R</h4></section></summary><div class=\"docblock\"><p>Call the given function with a copy of the exception term, from a context where the exception state has temporarily been cleared.</p>\n<p>This allows analysis on the exception term using all the\nnormal safe functions for doing so. When the function returns,\nthe engine will go back into an exceptional state with the\noriginal exception term.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.raise_exception\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#282-293\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.raise_exception\" class=\"fn\">raise_exception</a>&lt;R&gt;(&amp;self, term: &amp;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;) -&gt; <a class=\"type\" href=\"swipl/result/type.PrologResult.html\" title=\"type swipl::result::PrologResult\">PrologResult</a>&lt;R&gt;</h4></section></summary><div class=\"docblock\"><p>Put the engine in an exceptional state.</p>\n<p>The given term will be copied and put into the exception\nterm. This function always returns\n<code>Err(PrologError::Exception)</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.current_output\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#296-303\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.current_output\" class=\"fn\">current_output</a>&lt;'b&gt;(&amp;self) -&gt; <a class=\"struct\" href=\"swipl/stream/struct.WritablePrologStream.html\" title=\"struct swipl::stream::WritablePrologStream\">WritablePrologStream</a>&lt;'b&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"WritablePrologStream&lt;&#39;b&gt;\">ⓘ</a></h4></section></summary><div class=\"docblock\"><p>Retrieve the current output stream.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.handle_signals\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#321-329\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.handle_signals\" class=\"fn\">handle_signals</a>(&amp;self) -&gt; <a class=\"type\" href=\"swipl/result/type.PrologResult.html\" title=\"type swipl::result::PrologResult\">PrologResult</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.u32.html\">u32</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Handle any outstanding synchronous signals, including user interrupts.</p>\n<p>This could return PrologError::Exception, which should\nnormally be propagated all the way back to SWI-Prolog. In\nparticular, the raised exception will be a term containing the\natom ‘$aborted’ for the case where a user interrupts.</p>\n<p>This should be regularly called for long-running foreign code.\nSWI-Prolog handles signals synchronously at safe points, and\ntherefore will never do so while a foreign predicate is\nrunning. The most visible outcome of this is that long-running\npredicates can normally not be interrupted by the user when\nthey press ctrl-c once.</p>\n<p>On success, the number of outstanding signals handled is\nreturned.</p>\n</div></details></div></details>",0,"swipl::context::GenericQueryableContext"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Context%3C'a,+C%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#600-619\">source</a><a href=\"#impl-Context%3C'a,+C%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, C: <a class=\"trait\" href=\"swipl/context/trait.FrameableContextType.html\" title=\"trait swipl::context::FrameableContextType\">FrameableContextType</a>&gt; <a class=\"struct\" href=\"swipl/context/struct.Context.html\" title=\"struct swipl::context::Context\">Context</a>&lt;'a, C&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.open_frame\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#607-618\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.open_frame\" class=\"fn\">open_frame</a>(&amp;self) -&gt; <a class=\"struct\" href=\"swipl/context/struct.Context.html\" title=\"struct swipl::context::Context\">Context</a>&lt;'_, <a class=\"struct\" href=\"swipl/context/struct.Frame.html\" title=\"struct swipl::context::Frame\">Frame</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Open a new frame.</p>\n<p>This returns a new context for the frame. The current context\nwill become inactive, until the new context is dropped. This\nmay happen implicitely, when it goes out of scope, or\nexplicitely, by calling <code>close()</code> or <code>discard()</code> on it.</p>\n</div></details></div></details>",0,"swipl::context::GenericQueryableContext"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Context%3C'a,+T%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#637-1099\">source</a><a href=\"#impl-Context%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T: <a class=\"trait\" href=\"swipl/context/trait.QueryableContextType.html\" title=\"trait swipl::context::QueryableContextType\">QueryableContextType</a>&gt; <a class=\"struct\" href=\"swipl/context/struct.Context.html\" title=\"struct swipl::context::Context\">Context</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_term_ref\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#642-648\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.new_term_ref\" class=\"fn\">new_term_ref</a>(&amp;self) -&gt; <a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;</h4></section></summary><div class=\"docblock\"><p>Create a new Term reference in the current context.</p>\n<p>The term ref takes on the lifetime of the Context reference,\nensuring that it cannot outlive the context that created it.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_term_refs\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#655-682\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.new_term_refs\" class=\"fn\">new_term_refs</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.usize.html\">usize</a>&gt;(&amp;self) -&gt; [<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.array.html\">N</a>]</h4></section></summary><div class=\"docblock\"><p>create an array of term references.</p>\n<p>The term refs all take on the lifetime of the Context\nreference, ensuring that it cannot outlive the context that\ncreated it.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_term_refs_vec\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#689-700\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.new_term_refs_vec\" class=\"fn\">new_term_refs_vec</a>(&amp;self, count: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.76.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>create a vec of term references.</p>\n<p>The term refs all take on the lifetime of the Context\nreference, ensuring that it cannot outlive the context that\ncreated it.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.open\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#721-727\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.open\" class=\"fn\">open</a>&lt;C: <a class=\"trait\" href=\"swipl/callable/trait.Callable.html\" title=\"trait swipl::callable::Callable\">Callable</a>&lt;N&gt;, const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;self,\n    callable: C,\n    args: [&amp;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.array.html\">N</a>]\n) -&gt; <a class=\"struct\" href=\"swipl/context/struct.Context.html\" title=\"struct swipl::context::Context\">Context</a>&lt;'_, C::<a class=\"associatedtype\" href=\"swipl/callable/trait.Callable.html#associatedtype.ContextType\" title=\"type swipl::callable::Callable::ContextType\">ContextType</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Open a query.</p>\n<p>Example:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>\n   <span class=\"kw\">let </span>query = context.open(<span class=\"macro\">pred!</span>{format/<span class=\"number\">2</span>},\n                            [<span class=\"kw-2\">&amp;</span><span class=\"macro\">term!</span>{context: <span class=\"string\">\"hello, ~q~n\"</span>}<span class=\"question-mark\">?</span>,\n                             <span class=\"kw-2\">&amp;</span><span class=\"macro\">term!</span>{context: [<span class=\"string\">\"world\"</span>]}<span class=\"question-mark\">?</span>]);\n   query.next_solution()<span class=\"question-mark\">?</span>;\n   query.cut();</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.call_once\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#746-756\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.call_once\" class=\"fn\">call_once</a>&lt;C: <a class=\"trait\" href=\"swipl/callable/trait.Callable.html\" title=\"trait swipl::callable::Callable\">Callable</a>&lt;N&gt;, const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;self,\n    callable: C,\n    args: [&amp;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.array.html\">N</a>]\n) -&gt; <a class=\"type\" href=\"swipl/result/type.PrologResult.html\" title=\"type swipl::result::PrologResult\">PrologResult</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Open a query, get a single result and cut.</p>\n<p>Example:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>\n   context.call_once(<span class=\"macro\">pred!</span>{format/<span class=\"number\">2</span>},\n                     [<span class=\"kw-2\">&amp;</span><span class=\"macro\">term!</span>{context: <span class=\"string\">\"hello, ~q~n\"</span>}<span class=\"question-mark\">?</span>,\n                     <span class=\"kw-2\">&amp;</span><span class=\"macro\">term!</span>{context: [<span class=\"string\">\"world\"</span>]}<span class=\"question-mark\">?</span>])<span class=\"question-mark\">?</span>;</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.open_with_module\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#759-766\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.open_with_module\" class=\"fn\">open_with_module</a>&lt;C: <a class=\"trait\" href=\"swipl/callable/trait.Callable.html\" title=\"trait swipl::callable::Callable\">Callable</a>&lt;N&gt;, const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;self,\n    callable: C,\n    module: <a class=\"enum\" href=\"https://doc.rust-lang.org/1.76.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"swipl/module/struct.Module.html\" title=\"struct swipl::module::Module\">Module</a>&gt;,\n    args: [&amp;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.array.html\">N</a>]\n) -&gt; <a class=\"struct\" href=\"swipl/context/struct.Context.html\" title=\"struct swipl::context::Context\">Context</a>&lt;'_, C::<a class=\"associatedtype\" href=\"swipl/callable/trait.Callable.html#associatedtype.ContextType\" title=\"type swipl::callable::Callable::ContextType\">ContextType</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Open a query, optionally passing in a context module.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.term_from_string\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#774-788\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.term_from_string\" class=\"fn\">term_from_string</a>(&amp;self, s: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.str.html\">str</a>) -&gt; <a class=\"type\" href=\"swipl/result/type.PrologResult.html\" title=\"type swipl::result::PrologResult\">PrologResult</a>&lt;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Turn the given string into a prolog term.</p>\n<p>This uses the prolog predicate <code>read_term_from_atom/3</code> for the\nheavy lifting.</p>\n<p>Consider using the <code>term!</code> macro instead.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.string_from_term\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#796-805\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.string_from_term\" class=\"fn\">string_from_term</a>(&amp;self, t: &amp;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;) -&gt; <a class=\"type\" href=\"swipl/result/type.PrologResult.html\" title=\"type swipl::result::PrologResult\">PrologResult</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/1.76.0/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Turn the given string into a prolog term.</p>\n<p>This uses the prolog predicate <code>read_term_from_atom/3</code> for the\nheavy lifting.</p>\n<p>Consider using the <code>term!</code> macro instead.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.open_call\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#808-810\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.open_call\" class=\"fn\">open_call</a>(&amp;'a self, t: &amp;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'a&gt;) -&gt; <a class=\"struct\" href=\"swipl/context/struct.Context.html\" title=\"struct swipl::context::Context\">Context</a>&lt;'a, impl <a class=\"trait\" href=\"swipl/callable/trait.OpenCall.html\" title=\"trait swipl::callable::OpenCall\">OpenCall</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Open a query for the given term using the <code>call/1</code> prolog predicate.</p>\n</div></details><section id=\"method.call_term_once\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#812-818\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.call_term_once\" class=\"fn\">call_term_once</a>(&amp;'a self, t: &amp;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'a&gt;) -&gt; <a class=\"type\" href=\"swipl/result/type.PrologResult.html\" title=\"type swipl::result::PrologResult\">PrologResult</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.unit.html\">()</a>&gt;</h4></section><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_or_die\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#825-840\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.try_or_die\" class=\"fn\">try_or_die</a>&lt;R, E: <a class=\"trait\" href=\"swipl/context/trait.IntoPrologException.html\" title=\"trait swipl::context::IntoPrologException\">IntoPrologException</a>&gt;(\n    &amp;self,\n    r: <a class=\"enum\" href=\"https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;R, E&gt;\n) -&gt; <a class=\"type\" href=\"swipl/result/type.PrologResult.html\" title=\"type swipl::result::PrologResult\">PrologResult</a>&lt;R&gt;</h4></section></summary><div class=\"docblock\"><p>Turn a result into a <code>PrologResult</code>.</p>\n<p>For this to work, the <code>Err</code> component of the <code>Result</code> needs to\nimplement the trait <code>IntoPrologException</code>. This is currently\nonly the case for <a href=\"https://doc.rust-lang.org/1.76.0/std/io/error/struct.Error.html\" title=\"struct std::io::error::Error\">std::io::Error</a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_or_die_generic\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#846-867\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.try_or_die_generic\" class=\"fn\">try_or_die_generic</a>&lt;R, E: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.76.0/core/error/trait.Error.html\" title=\"trait core::error::Error\">Error</a>&gt;(\n    &amp;self,\n    r: <a class=\"enum\" href=\"https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;R, E&gt;\n) -&gt; <a class=\"type\" href=\"swipl/result/type.PrologResult.html\" title=\"type swipl::result::PrologResult\">PrologResult</a>&lt;R&gt;</h4></section></summary><div class=\"docblock\"><p>Turn a result into a <code>PrologResult</code>.</p>\n<p>For this to work, the <code>Err</code> component of the <code>Result</code> needs to\nimplement the trait <a href=\"https://doc.rust-lang.org/1.76.0/core/error/trait.Error.html\" title=\"trait core::error::Error\">Error</a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.term_list_iter\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#881-886\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.term_list_iter\" class=\"fn\">term_list_iter</a>&lt;'b&gt;(\n    &amp;'b self,\n    list: &amp;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;\n) -&gt; <a class=\"struct\" href=\"swipl/context/struct.TermListIterator.html\" title=\"struct swipl::context::TermListIterator\">TermListIterator</a>&lt;'b, 'a, T&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"TermListIterator&lt;&#39;b, &#39;a, T&gt;\">ⓘ</a></h4></section></summary><div class=\"docblock\"><p>Iterate over a term list.</p>\n<p>this returns a TermListIterator made out of the given\nterm. The TermListIterator will assume this is a cons cell,\nand unify head and tail on each step of the iterator,\nreturning the head term and storing the tail term. If this\nunification fails, the iterator stops.</p>\n<p>Note that the terms created by this iterator are not\nautomatically thrown away. It is the caller’s responsibility\nto clean up terms if this is required, for example by using a\nframe.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.term_list_array\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#894-909\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.term_list_array\" class=\"fn\">term_list_array</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.usize.html\">usize</a>&gt;(&amp;self, list: &amp;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;) -&gt; [<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.array.html\">N</a>]</h4></section></summary><div class=\"docblock\"><p>Retrieve a term list as a fixed-size array.</p>\n<p>This is useful when a term contains a list whose supposed size\nis known at compile time. If the actual list is larger than\nthis, only the first N elements are used. If the list is\nsmaller, the remaining terms in the array remain variables.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.term_list_vec\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#926-945\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.term_list_vec\" class=\"fn\">term_list_vec</a>(&amp;self, list: &amp;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.76.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieve a term list as a Vec.</p>\n<p>This will iterate over the given prolog list twice - once to\nfigure out its size, and then another time to actually\nretrieve the elements. This is done so that we can allocate\nthe terms in a way that leaves no unused terms behind on the\nstack (as would normally happen when iterating the list using\n<a href=\"swipl/context/struct.Context.html#method.term_list_iter\" title=\"method swipl::context::Context::term_list_iter\">term_list_iter</a>).</p>\n<p>If you know in advance what the size is going to be (or you\nknow a reasonable upper bound), consider using\n<a href=\"swipl/context/struct.Context.html#method.term_list_array\" title=\"method swipl::context::Context::term_list_array\">term_list_array</a>. If you just wish\nto iterate over the elements, or don’t care about garbage\nterms being created, consider using\n<a href=\"swipl/context/struct.Context.html#method.term_list_iter\" title=\"method swipl::context::Context::term_list_iter\">term_list_iter</a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.compound_terms\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#953-977\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.compound_terms\" class=\"fn\">compound_terms</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;self,\n    compound: &amp;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;\n) -&gt; <a class=\"type\" href=\"swipl/result/type.PrologResult.html\" title=\"type swipl::result::PrologResult\">PrologResult</a>&lt;[<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.array.html\">N</a>]&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieve compound terms as a fixed size array.</p>\n<p>This will ensure that the given term is indeed a compound with\narity N. If this is true, N terms will be allocated in this\ncontext, unified with the argument terms of the compound, and\nreturned as an array. If not, this method will fail.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.compound_terms_vec\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#985-1003\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.compound_terms_vec\" class=\"fn\">compound_terms_vec</a>(\n    &amp;self,\n    compound: &amp;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;\n) -&gt; <a class=\"type\" href=\"swipl/result/type.PrologResult.html\" title=\"type swipl::result::PrologResult\">PrologResult</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/1.76.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieve compound terms as a Vec.</p>\n<p>This will ensure that the given term is indeed a compound of\nany arity. If this is true, arity terms will be allocated in\nthis context, unified with the argument terms of the compound,\nand returned as a Vec. If not, this method will fail.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.compound_terms_vec_sized\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#1012-1037\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.compound_terms_vec_sized\" class=\"fn\">compound_terms_vec_sized</a>(\n    &amp;self,\n    compound: &amp;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;,\n    count: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.usize.html\">usize</a>\n) -&gt; <a class=\"type\" href=\"swipl/result/type.PrologResult.html\" title=\"type swipl::result::PrologResult\">PrologResult</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/1.76.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieve compound terms as a fixed size Vec.</p>\n<p>This will ensure that the given term is indeed a compound with\narity <code>count</code>. If this is true, <code>count</code> terms will be\nallocated in this context, unified with the argument terms of\nthe compound, and returned as an array. If not, this method\nwill fail.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.deserialize_from_term\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#1041-1046\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.deserialize_from_term\" class=\"fn\">deserialize_from_term</a>&lt;'de, DT: <a class=\"trait\" href=\"https://docs.rs/serde/1.0.197/serde/de/trait.Deserialize.html\" title=\"trait serde::de::Deserialize\">Deserialize</a>&lt;'de&gt;&gt;(\n    &amp;'de self,\n    term: &amp;'de <a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'de&gt;\n) -&gt; <a class=\"type\" href=\"swipl/term/de/type.Result.html\" title=\"type swipl::term::de::Result\">Result</a>&lt;DT&gt;</h4></section></summary><div class=\"docblock\"><p>Deserialize a term into a rust value using serde.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.serialize_to_term\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#1054-1060\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.serialize_to_term\" class=\"fn\">serialize_to_term</a>&lt;ST: <a class=\"trait\" href=\"https://docs.rs/serde/1.0.197/serde/ser/trait.Serialize.html\" title=\"trait serde::ser::Serialize\">Serialize</a>&gt;(\n    &amp;self,\n    term: &amp;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;,\n    obj: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.reference.html\">&amp;ST</a>\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.unit.html\">()</a>, <a class=\"enum\" href=\"swipl/term/de/enum.Error.html\" title=\"enum swipl::term::de::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Serialize a value into a prolog term using serde.</p>\n<p>This uses the default serialization configuration, meaning:</p>\n<ul>\n<li>prolog dictionary tags will remain variables.</li>\n<li>struct type names are ignored and will not be set as the dictionary tag.</li>\n</ul>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.serialize_to_term_with_config\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#1064-1071\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.serialize_to_term_with_config\" class=\"fn\">serialize_to_term_with_config</a>&lt;ST: <a class=\"trait\" href=\"https://docs.rs/serde/1.0.197/serde/ser/trait.Serialize.html\" title=\"trait serde::ser::Serialize\">Serialize</a>&gt;(\n    &amp;self,\n    term: &amp;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;,\n    obj: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.reference.html\">&amp;ST</a>,\n    config: <a class=\"struct\" href=\"swipl/term/ser/struct.SerializerConfiguration.html\" title=\"struct swipl::term::ser::SerializerConfiguration\">SerializerConfiguration</a>\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.76.0/std/primitive.unit.html\">()</a>, <a class=\"enum\" href=\"swipl/term/de/enum.Error.html\" title=\"enum swipl::term::de::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Serialize a value into a prolog term using serde, providing configuration options.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.unify_list_functor\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#1074-1092\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.unify_list_functor\" class=\"fn\">unify_list_functor</a>&lt;'b&gt;(\n    &amp;'b self,\n    term: &amp;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'_&gt;\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;(<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'b&gt;, <a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'b&gt;), <a class=\"enum\" href=\"swipl/result/enum.PrologError.html\" title=\"enum swipl::result::PrologError\">PrologError</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Unify the term with the list functor, returning a term for the head and the tail.</p>\n</div></details><section id=\"method.into_generic\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#1094-1098\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.into_generic\" class=\"fn\">into_generic</a>(&amp;self) -&gt; <a class=\"type\" href=\"swipl/context/type.GenericQueryableContext.html\" title=\"type swipl::context::GenericQueryableContext\">GenericQueryableContext</a>&lt;'_&gt;</h4></section></div></details>",0,"swipl::context::GenericQueryableContext"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Context%3C'a,+T%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/swipl/dict.rs.html#369-403\">source</a><a href=\"#impl-Context%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T: <a class=\"trait\" href=\"swipl/context/trait.QueryableContextType.html\" title=\"trait swipl::context::QueryableContextType\">QueryableContextType</a>&gt; <a class=\"struct\" href=\"swipl/context/struct.Context.html\" title=\"struct swipl::context::Context\">Context</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.dict_entries\" class=\"method\"><a class=\"src rightside\" href=\"src/swipl/dict.rs.html#384-402\">source</a><h4 class=\"code-header\">pub fn <a href=\"swipl/context/struct.Context.html#tymethod.dict_entries\" class=\"fn\">dict_entries</a>&lt;'b&gt;(&amp;'b self, term: &amp;<a class=\"struct\" href=\"swipl/term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'b&gt;) -&gt; <a class=\"struct\" href=\"swipl/dict/struct.DictIterator.html\" title=\"struct swipl::dict::DictIterator\">DictIterator</a>&lt;'a, 'b, T&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"DictIterator&lt;&#39;a, &#39;b, T&gt;\">ⓘ</a></h4></section></summary><div class=\"docblock\"><p>Iterate over the entries in the dictionary referred to by this term.</p>\n<p>This will return key-value pairs, where the key is either an\natom or an integer, and the value is a term. The term will be\ncreated in the current context. A consequence of this is that\nthe iterator will panic if this context is not active.</p>\n<p>Created terms will not be automatically unallocated when the\niterator moves on. It is the responsibility of the caller to\nclear them if desired using either a frame or by resetting.</p>\n<p>If <code>dict_entries</code> is called on a term that does not contain a\ndictionary, the iterator is still created but will not return\nany elements.</p>\n</div></details></div></details>",0,"swipl::context::GenericQueryableContext"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Drop-for-Context%3C'a,+T%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#344-350\">source</a><a href=\"#impl-Drop-for-Context%3C'a,+T%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, T: <a class=\"trait\" href=\"swipl/context/trait.ContextType.html\" title=\"trait swipl::context::ContextType\">ContextType</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.76.0/core/ops/drop/trait.Drop.html\" title=\"trait core::ops::drop::Drop\">Drop</a> for <a class=\"struct\" href=\"swipl/context/struct.Context.html\" title=\"struct swipl::context::Context\">Context</a>&lt;'a, T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.drop\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/swipl/context.rs.html#345-349\">source</a><a href=\"#method.drop\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.76.0/core/ops/drop/trait.Drop.html#tymethod.drop\" class=\"fn\">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Executes the destructor for this type. <a href=\"https://doc.rust-lang.org/1.76.0/core/ops/drop/trait.Drop.html#tymethod.drop\">Read more</a></div></details></div></details>","Drop","swipl::context::GenericQueryableContext"]]
};if (window.register_type_impls) {window.register_type_impls(type_impls);} else {window.pending_type_impls = type_impls;}})()