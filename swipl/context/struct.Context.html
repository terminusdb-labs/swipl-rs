<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A context that the underlying prolog engine is in."><title>Context in swipl::context - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="swipl" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0 (cc66ad468 2023-10-03)" data-channel="1.73.0" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-1596385f77d47ef2.css" data-theme-dark-css="dark-0a43001d3fc2282c.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-1596385f77d47ef2.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-0a43001d3fc2282c.css"><link rel="stylesheet" href="../../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../swipl/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../swipl/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Context</a></h2><div class="sidebar-elems"><section><h3><a href="#fields">Fields</a></h3><ul class="block"><li><a href="#structfield.context">context</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.assert_activated">assert_activated</a></li><li><a href="#method.assert_no_exception">assert_no_exception</a></li><li><a href="#method.call_once">call_once</a></li><li><a href="#method.call_term_once">call_term_once</a></li><li><a href="#method.clear_exception">clear_exception</a></li><li><a href="#method.close">close</a></li><li><a href="#method.compound_terms">compound_terms</a></li><li><a href="#method.compound_terms_vec">compound_terms_vec</a></li><li><a href="#method.compound_terms_vec_sized">compound_terms_vec_sized</a></li><li><a href="#method.current_output">current_output</a></li><li><a href="#method.cut">cut</a></li><li><a href="#method.deserialize_from_term">deserialize_from_term</a></li><li><a href="#method.dict_entries">dict_entries</a></li><li><a href="#method.discard">discard</a></li><li><a href="#method.discard-1">discard</a></li><li><a href="#method.engine_ptr">engine_ptr</a></li><li><a href="#method.has_exception">has_exception</a></li><li><a href="#method.ignore">ignore</a></li><li><a href="#method.into_generic">into_generic</a></li><li><a href="#method.new_term_ref">new_term_ref</a></li><li><a href="#method.new_term_refs">new_term_refs</a></li><li><a href="#method.new_term_refs_vec">new_term_refs_vec</a></li><li><a href="#method.next_solution">next_solution</a></li><li><a href="#method.once">once</a></li><li><a href="#method.open">open</a></li><li><a href="#method.open_call">open_call</a></li><li><a href="#method.open_frame">open_frame</a></li><li><a href="#method.open_with_module">open_with_module</a></li><li><a href="#method.raise_exception">raise_exception</a></li><li><a href="#method.rewind">rewind</a></li><li><a href="#method.serialize_to_term">serialize_to_term</a></li><li><a href="#method.serialize_to_term_with_config">serialize_to_term_with_config</a></li><li><a href="#method.string_from_term">string_from_term</a></li><li><a href="#method.term_from_string">term_from_string</a></li><li><a href="#method.term_list_array">term_list_array</a></li><li><a href="#method.term_list_iter">term_list_iter</a></li><li><a href="#method.term_list_vec">term_list_vec</a></li><li><a href="#method.try_or_die">try_or_die</a></li><li><a href="#method.try_or_die_generic">try_or_die_generic</a></li><li><a href="#method.unify_list_functor">unify_list_functor</a></li><li><a href="#method.with_exception">with_exception</a></li><li><a href="#method.with_uncleared_exception">with_uncleared_exception</a></li><li><a href="#method.wrap_term_ref">wrap_term_ref</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Drop-for-Context%3C'a,+T%3E">Drop</a></li><li><a href="#impl-From%3CEngineActivation%3C'a%3E%3E-for-Context%3C'a,+ActivatedEngine%3C'a%3E%3E">From&lt;EngineActivation&lt;&#x27;a&gt;&gt;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-Context%3C'a,+T%3E">!RefUnwindSafe</a></li><li><a href="#impl-Send-for-Context%3C'a,+T%3E">!Send</a></li><li><a href="#impl-Sync-for-Context%3C'a,+T%3E">!Sync</a></li><li><a href="#impl-UnwindSafe-for-Context%3C'a,+T%3E">!UnwindSafe</a></li><li><a href="#impl-Unpin-for-Context%3C'a,+T%3E">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-Context%3C'a,+T%3E">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-Context%3C'a,+T%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-Context%3C'a,+T%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-Context%3C'a,+T%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-Context%3C'a,+T%3E">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-Context%3C'a,+T%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-Context%3C'a,+T%3E">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In swipl::context</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../index.html">swipl</a>::<wbr><a href="index.html">context</a>::<wbr><a class="struct" href="#">Context</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/swipl/context.rs.html#143-149">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct Context&lt;'a, T: <a class="trait" href="trait.ContextType.html" title="trait swipl::context::ContextType">ContextType</a>&gt; {
    pub context: T,
    /* private fields */
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A context that the underlying prolog engine is in.</p>
<p>See the module documentation for an explanation of this type.</p>
</div></details><h2 id="fields" class="fields small-section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.context" class="structfield small-section-header"><a href="#structfield.context" class="anchor field">§</a><code>context: T</code></span><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Context%3C'a,+C%3E" class="impl"><a class="src rightside" href="../../src/swipl/callable.rs.html#195-242">source</a><a href="#impl-Context%3C'a,+C%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, C: <a class="trait" href="../callable/trait.OpenCall.html" title="trait swipl::callable::OpenCall">OpenCall</a>&gt; <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'a, C&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.next_solution" class="method"><a class="src rightside" href="../../src/swipl/callable.rs.html#202-204">source</a><h4 class="code-header">pub fn <a href="#method.next_solution" class="fn">next_solution</a>(&amp;self) -&gt; <a class="type" href="../result/type.PrologResult.html" title="type swipl::result::PrologResult">PrologResult</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Retrieve the next solution.</p>
<p>If solution retrieval led to a failure or an error, this is
returned in the <code>Err</code> part of the <code>PrologResult</code>. Otherwise,
<code>Ok(true)</code> is returned if there are more solutions, and
<code>Ok(false)</code> is returned when this is the last solution.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.cut" class="method"><a class="src rightside" href="../../src/swipl/callable.rs.html#210-212">source</a><h4 class="code-header">pub fn <a href="#method.cut" class="fn">cut</a>(self)</h4></section></summary><div class="docblock"><p>Cut the query, keeping all data it has created.</p>
<p>Any unifications the query did to terms from parent contexts
will be retained.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.discard" class="method"><a class="src rightside" href="../../src/swipl/callable.rs.html#218-220">source</a><h4 class="code-header">pub fn <a href="#method.discard" class="fn">discard</a>(self)</h4></section></summary><div class="docblock"><p>Discard the query, discarding all data it has created.</p>
<p>Any unifications the query did to terms from parent contexts
will be discarded.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.once" class="method"><a class="src rightside" href="../../src/swipl/callable.rs.html#223-228">source</a><h4 class="code-header">pub fn <a href="#method.once" class="fn">once</a>(self) -&gt; <a class="type" href="../result/type.PrologResult.html" title="type swipl::result::PrologResult">PrologResult</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Retrieve one result, and then cut.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ignore" class="method"><a class="src rightside" href="../../src/swipl/callable.rs.html#233-241">source</a><h4 class="code-header">pub fn <a href="#method.ignore" class="fn">ignore</a>(self) -&gt; <a class="type" href="../result/type.PrologResult.html" title="type swipl::result::PrologResult">PrologResult</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Retrieve one result, ignoring failures, and then cut.</p>
<p>Exceptions will still be returned as such.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Context%3C'a,+T%3E" class="impl"><a class="src rightside" href="../../src/swipl/context.rs.html#151-302">source</a><a href="#impl-Context%3C'a,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T: <a class="trait" href="trait.ContextType.html" title="trait swipl::context::ContextType">ContextType</a>&gt; <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'a, T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.assert_activated" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#181-185">source</a><h4 class="code-header">pub fn <a href="#method.assert_activated" class="fn">assert_activated</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Panics if this context is not active.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assert_no_exception" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#188-192">source</a><h4 class="code-header">pub fn <a href="#method.assert_no_exception" class="fn">assert_no_exception</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Panics if the engine is in an exceptional state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.engine_ptr" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#195-197">source</a><h4 class="code-header">pub fn <a href="#method.engine_ptr" class="fn">engine_ptr</a>(&amp;self) -&gt; <a class="type" href="../fli/type.PL_engine_t.html" title="type swipl::fli::PL_engine_t">PL_engine_t</a></h4></section></summary><div class="docblock"><p>Returns the underlying engine pointer.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrap_term_ref" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#211-214">source</a><h4 class="code-header">pub unsafe fn <a href="#method.wrap_term_ref" class="fn">wrap_term_ref</a>(&amp;self, term: <a class="type" href="../fli/type.term_t.html" title="type swipl::fli::term_t">term_t</a>) -&gt; <a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Wrap the given term_t into a Term with a lifetime corresponding to this context.</p>
<h5 id="safety"><a href="#safety">Safety</a></h5>
<p>This is unsafe because there’s no way of checking that the
given term_t is indeed from this context. The caller will have
to ensure that the term lives at least as long as this
context.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.has_exception" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#217-221">source</a><h4 class="code-header">pub fn <a href="#method.has_exception" class="fn">has_exception</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if the underlying engine is in an exceptional state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.clear_exception" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#224-229">source</a><h4 class="code-header">pub fn <a href="#method.clear_exception" class="fn">clear_exception</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Clear the current exception if there is any.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_uncleared_exception" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#236-260">source</a><h4 class="code-header">pub fn <a href="#method.with_uncleared_exception" class="fn">with_uncleared_exception</a>&lt;'b, R&gt;(
    &amp;'b self,
    f: impl <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="enum" href="https://doc.rust-lang.org/1.73.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.ExceptionTerm.html" title="struct swipl::context::ExceptionTerm">ExceptionTerm</a>&lt;'b&gt;&gt;) -&gt; R
) -&gt; R</h4></section></summary><div class="docblock"><p>Call the given function with the exception term, if it exists.</p>
<p>The given function is able to clear the exception term, but
not much else is allowed from safe code. Any attempt to do a
get, put or unify with the given term will result in a panic.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_exception" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#268-273">source</a><h4 class="code-header">pub fn <a href="#method.with_exception" class="fn">with_exception</a>&lt;R&gt;(&amp;self, f: impl <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="enum" href="https://doc.rust-lang.org/1.73.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;&gt;) -&gt; R) -&gt; R</h4></section></summary><div class="docblock"><p>Call the given function with a copy of the exception term, from a context where the exception state has temporarily been cleared.</p>
<p>This allows analysis on the exception term using all the
normal safe functions for doing so. When the function returns,
the engine will go back into an exceptional state with the
original exception term.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.raise_exception" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#280-291">source</a><h4 class="code-header">pub fn <a href="#method.raise_exception" class="fn">raise_exception</a>&lt;R&gt;(&amp;self, term: &amp;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;) -&gt; <a class="type" href="../result/type.PrologResult.html" title="type swipl::result::PrologResult">PrologResult</a>&lt;R&gt;</h4></section></summary><div class="docblock"><p>Put the engine in an exceptional state.</p>
<p>The given term will be copied and put into the exception
term. This function always returns
<code>Err(PrologError::Exception)</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.current_output" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#294-301">source</a><h4 class="code-header">pub fn <a href="#method.current_output" class="fn">current_output</a>&lt;'b&gt;(&amp;self) -&gt; <a class="struct" href="../stream/struct.WritablePrologStream.html" title="struct swipl::stream::WritablePrologStream">WritablePrologStream</a>&lt;'b&gt; <a href="#" class="tooltip" data-notable-ty="WritablePrologStream&lt;&#39;b&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Retrieve the current output stream.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Context%3C'a,+Frame%3E" class="impl"><a class="src rightside" href="../../src/swipl/context.rs.html#525-564">source</a><a href="#impl-Context%3C'a,+Frame%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'a, <a class="struct" href="struct.Frame.html" title="struct swipl::context::Frame">Frame</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.close" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#531-535">source</a><h4 class="code-header">pub fn <a href="#method.close" class="fn">close</a>(self)</h4></section></summary><div class="docblock"><p>Close the frame.</p>
<p>After closing, any terms created in the context of this frame
will no longer be usable. Any data created and put in terms
that are still in scope will be retained.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.discard-1" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#543-546">source</a><h4 class="code-header">pub fn <a href="#method.discard-1" class="fn">discard</a>(self)</h4></section></summary><div class="docblock"><p>Discard the frame.</p>
<p>This will destroy the frame. Any terms created in the context
of this frame will no longer be usable. Furthermore, any term
manipulation that happened since opening this frame will be
undone. This is equivalent to a rewind followed by a close.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rewind" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#557-563">source</a><h4 class="code-header">pub fn <a href="#method.rewind" class="fn">rewind</a>(self) -&gt; <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'a, <a class="struct" href="struct.Frame.html" title="struct swipl::context::Frame">Frame</a>&gt;</h4></section></summary><div class="docblock"><p>Rewind the frame.</p>
<p>This will rewind the frame. Any terms created in the context
of this frame will no longer be usable. Furthermore, any term
manipulation that happened since opening this frame will be
undone.</p>
<p>This returns a new context which is to be used for further
manipulation of this frame.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Context%3C'a,+C%3E-1" class="impl"><a class="src rightside" href="../../src/swipl/context.rs.html#572-591">source</a><a href="#impl-Context%3C'a,+C%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;'a, C: <a class="trait" href="trait.FrameableContextType.html" title="trait swipl::context::FrameableContextType">FrameableContextType</a>&gt; <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'a, C&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.open_frame" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#579-590">source</a><h4 class="code-header">pub fn <a href="#method.open_frame" class="fn">open_frame</a>(&amp;self) -&gt; <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'_, <a class="struct" href="struct.Frame.html" title="struct swipl::context::Frame">Frame</a>&gt;</h4></section></summary><div class="docblock"><p>Open a new frame.</p>
<p>This returns a new context for the frame. The current context
will become inactive, until the new context is dropped. This
may happen implicitely, when it goes out of scope, or
explicitely, by calling <code>close()</code> or <code>discard()</code> on it.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Context%3C'a,+T%3E-1" class="impl"><a class="src rightside" href="../../src/swipl/context.rs.html#609-1070">source</a><a href="#impl-Context%3C'a,+T%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T: <a class="trait" href="trait.QueryableContextType.html" title="trait swipl::context::QueryableContextType">QueryableContextType</a>&gt; <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'a, T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new_term_ref" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#614-620">source</a><h4 class="code-header">pub fn <a href="#method.new_term_ref" class="fn">new_term_ref</a>(&amp;self) -&gt; <a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Create a new Term reference in the current context.</p>
<p>The term ref takes on the lifetime of the Context reference,
ensuring that it cannot outlive the context that created it.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_term_refs" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#627-650">source</a><h4 class="code-header">pub fn <a href="#method.new_term_refs" class="fn">new_term_refs</a>&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.usize.html">usize</a>&gt;(&amp;self) -&gt; [<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.array.html">N</a>]</h4></section></summary><div class="docblock"><p>create an array of term references.</p>
<p>The term refs all take on the lifetime of the Context
reference, ensuring that it cannot outlive the context that
created it.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_term_refs_vec" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#657-671">source</a><h4 class="code-header">pub fn <a href="#method.new_term_refs_vec" class="fn">new_term_refs_vec</a>(&amp;self, count: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.73.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;&gt;</h4></section></summary><div class="docblock"><p>create a vec of term references.</p>
<p>The term refs all take on the lifetime of the Context
reference, ensuring that it cannot outlive the context that
created it.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.open" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#692-698">source</a><h4 class="code-header">pub fn <a href="#method.open" class="fn">open</a>&lt;C: <a class="trait" href="../callable/trait.Callable.html" title="trait swipl::callable::Callable">Callable</a>&lt;N&gt;, const N: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.usize.html">usize</a>&gt;(
    &amp;self,
    callable: C,
    args: [&amp;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.array.html">N</a>]
) -&gt; <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'_, C::<a class="associatedtype" href="../callable/trait.Callable.html#associatedtype.ContextType" title="type swipl::callable::Callable::ContextType">ContextType</a>&gt;</h4></section></summary><div class="docblock"><p>Open a query.</p>
<p>Example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
   <span class="kw">let </span>query = context.open(<span class="macro">pred!</span>{format/<span class="number">2</span>},
                            [<span class="kw-2">&amp;</span><span class="macro">term!</span>{context: <span class="string">&quot;hello, ~q~n&quot;</span>}<span class="question-mark">?</span>,
                             <span class="kw-2">&amp;</span><span class="macro">term!</span>{context: [<span class="string">&quot;world&quot;</span>]}<span class="question-mark">?</span>]);
   query.next_solution()<span class="question-mark">?</span>;
   query.cut();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.call_once" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#717-727">source</a><h4 class="code-header">pub fn <a href="#method.call_once" class="fn">call_once</a>&lt;C: <a class="trait" href="../callable/trait.Callable.html" title="trait swipl::callable::Callable">Callable</a>&lt;N&gt;, const N: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.usize.html">usize</a>&gt;(
    &amp;self,
    callable: C,
    args: [&amp;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.array.html">N</a>]
) -&gt; <a class="type" href="../result/type.PrologResult.html" title="type swipl::result::PrologResult">PrologResult</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Open a query, get a single result and cut.</p>
<p>Example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
   context.call_once(<span class="macro">pred!</span>{format/<span class="number">2</span>},
                     [<span class="kw-2">&amp;</span><span class="macro">term!</span>{context: <span class="string">&quot;hello, ~q~n&quot;</span>}<span class="question-mark">?</span>,
                     <span class="kw-2">&amp;</span><span class="macro">term!</span>{context: [<span class="string">&quot;world&quot;</span>]}<span class="question-mark">?</span>])<span class="question-mark">?</span>;</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.open_with_module" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#730-737">source</a><h4 class="code-header">pub fn <a href="#method.open_with_module" class="fn">open_with_module</a>&lt;C: <a class="trait" href="../callable/trait.Callable.html" title="trait swipl::callable::Callable">Callable</a>&lt;N&gt;, const N: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.usize.html">usize</a>&gt;(
    &amp;self,
    callable: C,
    module: <a class="enum" href="https://doc.rust-lang.org/1.73.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../module/struct.Module.html" title="struct swipl::module::Module">Module</a>&gt;,
    args: [&amp;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.array.html">N</a>]
) -&gt; <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'_, C::<a class="associatedtype" href="../callable/trait.Callable.html#associatedtype.ContextType" title="type swipl::callable::Callable::ContextType">ContextType</a>&gt;</h4></section></summary><div class="docblock"><p>Open a query, optionally passing in a context module.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.term_from_string" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#745-759">source</a><h4 class="code-header">pub fn <a href="#method.term_from_string" class="fn">term_from_string</a>(&amp;self, s: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.str.html">str</a>) -&gt; <a class="type" href="../result/type.PrologResult.html" title="type swipl::result::PrologResult">PrologResult</a>&lt;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;&gt;</h4></section></summary><div class="docblock"><p>Turn the given string into a prolog term.</p>
<p>This uses the prolog predicate <code>read_term_from_atom/3</code> for the
heavy lifting.</p>
<p>Consider using the <code>term!</code> macro instead.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.string_from_term" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#767-776">source</a><h4 class="code-header">pub fn <a href="#method.string_from_term" class="fn">string_from_term</a>(&amp;self, t: &amp;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;) -&gt; <a class="type" href="../result/type.PrologResult.html" title="type swipl::result::PrologResult">PrologResult</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.73.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>Turn the given string into a prolog term.</p>
<p>This uses the prolog predicate <code>read_term_from_atom/3</code> for the
heavy lifting.</p>
<p>Consider using the <code>term!</code> macro instead.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.open_call" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#779-781">source</a><h4 class="code-header">pub fn <a href="#method.open_call" class="fn">open_call</a>(&amp;'a self, t: &amp;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'a&gt;) -&gt; <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'a, impl <a class="trait" href="../callable/trait.OpenCall.html" title="trait swipl::callable::OpenCall">OpenCall</a>&gt;</h4></section></summary><div class="docblock"><p>Open a query for the given term using the <code>call/1</code> prolog predicate.</p>
</div></details><section id="method.call_term_once" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#783-789">source</a><h4 class="code-header">pub fn <a href="#method.call_term_once" class="fn">call_term_once</a>(&amp;'a self, t: &amp;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'a&gt;) -&gt; <a class="type" href="../result/type.PrologResult.html" title="type swipl::result::PrologResult">PrologResult</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.unit.html">()</a>&gt;</h4></section><details class="toggle method-toggle" open><summary><section id="method.try_or_die" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#796-811">source</a><h4 class="code-header">pub fn <a href="#method.try_or_die" class="fn">try_or_die</a>&lt;R, E: <a class="trait" href="trait.IntoPrologException.html" title="trait swipl::context::IntoPrologException">IntoPrologException</a>&gt;(
    &amp;self,
    r: <a class="enum" href="https://doc.rust-lang.org/1.73.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;R, E&gt;
) -&gt; <a class="type" href="../result/type.PrologResult.html" title="type swipl::result::PrologResult">PrologResult</a>&lt;R&gt;</h4></section></summary><div class="docblock"><p>Turn a result into a <code>PrologResult</code>.</p>
<p>For this to work, the <code>Err</code> component of the <code>Result</code> needs to
implement the trait <code>IntoPrologException</code>. This is currently
only the case for <a href="https://doc.rust-lang.org/1.73.0/std/io/error/struct.Error.html" title="struct std::io::error::Error">std::io::Error</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_or_die_generic" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#817-838">source</a><h4 class="code-header">pub fn <a href="#method.try_or_die_generic" class="fn">try_or_die_generic</a>&lt;R, E: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/error/trait.Error.html" title="trait core::error::Error">Error</a>&gt;(
    &amp;self,
    r: <a class="enum" href="https://doc.rust-lang.org/1.73.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;R, E&gt;
) -&gt; <a class="type" href="../result/type.PrologResult.html" title="type swipl::result::PrologResult">PrologResult</a>&lt;R&gt;</h4></section></summary><div class="docblock"><p>Turn a result into a <code>PrologResult</code>.</p>
<p>For this to work, the <code>Err</code> component of the <code>Result</code> needs to
implement the trait <a href="https://doc.rust-lang.org/1.73.0/core/error/trait.Error.html" title="trait core::error::Error">Error</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.term_list_iter" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#852-857">source</a><h4 class="code-header">pub fn <a href="#method.term_list_iter" class="fn">term_list_iter</a>&lt;'b&gt;(
    &amp;'b self,
    list: &amp;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;
) -&gt; <a class="struct" href="struct.TermListIterator.html" title="struct swipl::context::TermListIterator">TermListIterator</a>&lt;'b, 'a, T&gt; <a href="#" class="tooltip" data-notable-ty="TermListIterator&lt;&#39;b, &#39;a, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Iterate over a term list.</p>
<p>this returns a TermListIterator made out of the given
term. The TermListIterator will assume this is a cons cell,
and unify head and tail on each step of the iterator,
returning the head term and storing the tail term. If this
unification fails, the iterator stops.</p>
<p>Note that the terms created by this iterator are not
automatically thrown away. It is the caller’s responsibility
to clean up terms if this is required, for example by using a
frame.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.term_list_array" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#865-880">source</a><h4 class="code-header">pub fn <a href="#method.term_list_array" class="fn">term_list_array</a>&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.usize.html">usize</a>&gt;(&amp;self, list: &amp;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;) -&gt; [<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.array.html">N</a>]</h4></section></summary><div class="docblock"><p>Retrieve a term list as a fixed-size array.</p>
<p>This is useful when a term contains a list whose supposed size
is known at compile time. If the actual list is larger than
this, only the first N elements are used. If the list is
smaller, the remaining terms in the array remain variables.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.term_list_vec" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#897-916">source</a><h4 class="code-header">pub fn <a href="#method.term_list_vec" class="fn">term_list_vec</a>(&amp;self, list: &amp;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.73.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;&gt;</h4></section></summary><div class="docblock"><p>Retrieve a term list as a Vec.</p>
<p>This will iterate over the given prolog list twice - once to
figure out its size, and then another time to actually
retrieve the elements. This is done so that we can allocate
the terms in a way that leaves no unused terms behind on the
stack (as would normally happen when iterating the list using
<a href="struct.Context.html#method.term_list_iter" title="method swipl::context::Context::term_list_iter">term_list_iter</a>).</p>
<p>If you know in advance what the size is going to be (or you
know a reasonable upper bound), consider using
<a href="struct.Context.html#method.term_list_array" title="method swipl::context::Context::term_list_array">term_list_array</a>. If you just wish
to iterate over the elements, or don’t care about garbage
terms being created, consider using
<a href="struct.Context.html#method.term_list_iter" title="method swipl::context::Context::term_list_iter">term_list_iter</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.compound_terms" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#924-948">source</a><h4 class="code-header">pub fn <a href="#method.compound_terms" class="fn">compound_terms</a>&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.usize.html">usize</a>&gt;(
    &amp;self,
    compound: &amp;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;
) -&gt; <a class="type" href="../result/type.PrologResult.html" title="type swipl::result::PrologResult">PrologResult</a>&lt;[<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.array.html">N</a>]&gt;</h4></section></summary><div class="docblock"><p>Retrieve compound terms as a fixed size array.</p>
<p>This will ensure that the given term is indeed a compound with
arity N. If this is true, N terms will be allocated in this
context, unified with the argument terms of the compound, and
returned as an array. If not, this method will fail.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.compound_terms_vec" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#956-974">source</a><h4 class="code-header">pub fn <a href="#method.compound_terms_vec" class="fn">compound_terms_vec</a>(
    &amp;self,
    compound: &amp;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;
) -&gt; <a class="type" href="../result/type.PrologResult.html" title="type swipl::result::PrologResult">PrologResult</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.73.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;&gt;&gt;</h4></section></summary><div class="docblock"><p>Retrieve compound terms as a Vec.</p>
<p>This will ensure that the given term is indeed a compound of
any arity. If this is true, arity terms will be allocated in
this context, unified with the argument terms of the compound,
and returned as a Vec. If not, this method will fail.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.compound_terms_vec_sized" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#983-1008">source</a><h4 class="code-header">pub fn <a href="#method.compound_terms_vec_sized" class="fn">compound_terms_vec_sized</a>(
    &amp;self,
    compound: &amp;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;,
    count: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="type" href="../result/type.PrologResult.html" title="type swipl::result::PrologResult">PrologResult</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.73.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;&gt;&gt;</h4></section></summary><div class="docblock"><p>Retrieve compound terms as a fixed size Vec.</p>
<p>This will ensure that the given term is indeed a compound with
arity <code>count</code>. If this is true, <code>count</code> terms will be
allocated in this context, unified with the argument terms of
the compound, and returned as an array. If not, this method
will fail.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.deserialize_from_term" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#1012-1017">source</a><h4 class="code-header">pub fn <a href="#method.deserialize_from_term" class="fn">deserialize_from_term</a>&lt;'de, DT: <a class="trait" href="https://docs.rs/serde/1.0.189/serde/de/trait.Deserialize.html" title="trait serde::de::Deserialize">Deserialize</a>&lt;'de&gt;&gt;(
    &amp;'de self,
    term: &amp;'de <a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'de&gt;
) -&gt; <a class="type" href="../term/de/type.Result.html" title="type swipl::term::de::Result">Result</a>&lt;DT&gt;</h4></section></summary><div class="docblock"><p>Deserialize a term into a rust value using serde.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.serialize_to_term" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#1025-1031">source</a><h4 class="code-header">pub fn <a href="#method.serialize_to_term" class="fn">serialize_to_term</a>&lt;ST: <a class="trait" href="https://docs.rs/serde/1.0.189/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a>&gt;(
    &amp;self,
    term: &amp;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;,
    obj: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.reference.html">&amp;ST</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.73.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.unit.html">()</a>, <a class="enum" href="../term/de/enum.Error.html" title="enum swipl::term::de::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Serialize a value into a prolog term using serde.</p>
<p>This uses the default serialization configuration, meaning:</p>
<ul>
<li>prolog dictionary tags will remain variables.</li>
<li>struct type names are ignored and will not be set as the dictionary tag.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.serialize_to_term_with_config" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#1035-1042">source</a><h4 class="code-header">pub fn <a href="#method.serialize_to_term_with_config" class="fn">serialize_to_term_with_config</a>&lt;ST: <a class="trait" href="https://docs.rs/serde/1.0.189/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a>&gt;(
    &amp;self,
    term: &amp;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;,
    obj: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.reference.html">&amp;ST</a>,
    config: <a class="struct" href="../term/ser/struct.SerializerConfiguration.html" title="struct swipl::term::ser::SerializerConfiguration">SerializerConfiguration</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.73.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.unit.html">()</a>, <a class="enum" href="../term/de/enum.Error.html" title="enum swipl::term::de::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Serialize a value into a prolog term using serde, providing configuration options.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.unify_list_functor" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#1045-1063">source</a><h4 class="code-header">pub fn <a href="#method.unify_list_functor" class="fn">unify_list_functor</a>&lt;'b&gt;(
    &amp;'b self,
    term: &amp;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'_&gt;
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.73.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'b&gt;, <a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'b&gt;), <a class="enum" href="../result/enum.PrologError.html" title="enum swipl::result::PrologError">PrologError</a>&gt;</h4></section></summary><div class="docblock"><p>Unify the term with the list functor, returning a term for the head and the tail.</p>
</div></details><section id="method.into_generic" class="method"><a class="src rightside" href="../../src/swipl/context.rs.html#1065-1069">source</a><h4 class="code-header">pub fn <a href="#method.into_generic" class="fn">into_generic</a>(&amp;self) -&gt; <a class="type" href="type.GenericQueryableContext.html" title="type swipl::context::GenericQueryableContext">GenericQueryableContext</a>&lt;'_&gt;</h4></section></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Context%3C'a,+T%3E-2" class="impl"><a class="src rightside" href="../../src/swipl/dict.rs.html#367-401">source</a><a href="#impl-Context%3C'a,+T%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T: <a class="trait" href="trait.QueryableContextType.html" title="trait swipl::context::QueryableContextType">QueryableContextType</a>&gt; <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'a, T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.dict_entries" class="method"><a class="src rightside" href="../../src/swipl/dict.rs.html#382-400">source</a><h4 class="code-header">pub fn <a href="#method.dict_entries" class="fn">dict_entries</a>&lt;'b&gt;(&amp;'b self, term: &amp;<a class="struct" href="../term/struct.Term.html" title="struct swipl::term::Term">Term</a>&lt;'b&gt;) -&gt; <a class="struct" href="../dict/struct.DictIterator.html" title="struct swipl::dict::DictIterator">DictIterator</a>&lt;'a, 'b, T&gt; <a href="#" class="tooltip" data-notable-ty="DictIterator&lt;&#39;a, &#39;b, T&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Iterate over the entries in the dictionary referred to by this term.</p>
<p>This will return key-value pairs, where the key is either an
atom or an integer, and the value is a term. The term will be
created in the current context. A consequence of this is that
the iterator will panic if this context is not active.</p>
<p>Created terms will not be automatically unallocated when the
iterator moves on. It is the responsibility of the caller to
clear them if desired using either a frame or by resetting.</p>
<p>If <code>dict_entries</code> is called on a term that does not contain a
dictionary, the iterator is still created but will not return
any elements.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Drop-for-Context%3C'a,+T%3E" class="impl"><a class="src rightside" href="../../src/swipl/context.rs.html#316-322">source</a><a href="#impl-Drop-for-Context%3C'a,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T: <a class="trait" href="trait.ContextType.html" title="trait swipl::context::ContextType">ContextType</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'a, T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a class="src rightside" href="../../src/swipl/context.rs.html#317-321">source</a><a href="#method.drop" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/ops/drop/trait.Drop.html#tymethod.drop" class="fn">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Executes the destructor for this type. <a href="https://doc.rust-lang.org/1.73.0/core/ops/drop/trait.Drop.html#tymethod.drop">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CEngineActivation%3C'a%3E%3E-for-Context%3C'a,+ActivatedEngine%3C'a%3E%3E" class="impl"><a class="src rightside" href="../../src/swipl/context.rs.html#352-361">source</a><a href="#impl-From%3CEngineActivation%3C'a%3E%3E-for-Context%3C'a,+ActivatedEngine%3C'a%3E%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../engine/struct.EngineActivation.html" title="struct swipl::engine::EngineActivation">EngineActivation</a>&lt;'a&gt;&gt; for <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'a, <a class="struct" href="struct.ActivatedEngine.html" title="struct swipl::context::ActivatedEngine">ActivatedEngine</a>&lt;'a&gt;&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../../src/swipl/context.rs.html#353-360">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(activation: <a class="struct" href="../engine/struct.EngineActivation.html" title="struct swipl::engine::EngineActivation">EngineActivation</a>&lt;'a&gt;) -&gt; <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'a, <a class="struct" href="struct.ActivatedEngine.html" title="struct swipl::context::ActivatedEngine">ActivatedEngine</a>&lt;'a&gt;&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-Context%3C'a,+T%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Context%3C'a,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T&gt; !<a class="trait" href="https://doc.rust-lang.org/1.73.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'a, T&gt;</h3></section><section id="impl-Send-for-Context%3C'a,+T%3E" class="impl"><a href="#impl-Send-for-Context%3C'a,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T&gt; !<a class="trait" href="https://doc.rust-lang.org/1.73.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'a, T&gt;</h3></section><section id="impl-Sync-for-Context%3C'a,+T%3E" class="impl"><a href="#impl-Sync-for-Context%3C'a,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T&gt; !<a class="trait" href="https://doc.rust-lang.org/1.73.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'a, T&gt;</h3></section><section id="impl-Unpin-for-Context%3C'a,+T%3E" class="impl"><a href="#impl-Unpin-for-Context%3C'a,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'a, T&gt;<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</span></h3></section><section id="impl-UnwindSafe-for-Context%3C'a,+T%3E" class="impl"><a href="#impl-UnwindSafe-for-Context%3C'a,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T&gt; !<a class="trait" href="https://doc.rust-lang.org/1.73.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Context.html" title="struct swipl::context::Context">Context</a>&lt;'a, T&gt;</h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-Context%3C'a,+T%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/any.rs.html#135">source</a><a href="#impl-Any-for-Context%3C'a,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.73.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/any.rs.html#136">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.73.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.73.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-Context%3C'a,+T%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-Context%3C'a,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.73.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.73.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-Context%3C'a,+T%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-Context%3C'a,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.73.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.73.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-Context%3C'a,+T%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/convert/mod.rs.html#722">source</a><a href="#impl-From%3CT%3E-for-Context%3C'a,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/convert/mod.rs.html#725">source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-Context%3C'a,+T%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/convert/mod.rs.html#706">source</a><a href="#impl-Into%3CU%3E-for-Context%3C'a,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/convert/mod.rs.html#715">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.73.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-Context%3C'a,+T%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/convert/mod.rs.html#762">source</a><a href="#impl-TryFrom%3CU%3E-for-Context%3C'a,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.73.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/convert/mod.rs.html#769">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.73.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-Context%3C'a,+T%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/convert/mod.rs.html#747">source</a><a href="#impl-TryInto%3CU%3E-for-Context%3C'a,+T%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/convert/mod.rs.html#754">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.73.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"DictIterator<'a, 'b, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../dict/struct.DictIterator.html\" title=\"struct swipl::dict::DictIterator\">DictIterator</a>&lt;'a, 'b, T&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'a, 'b, T: <a class=\"trait\" href=\"trait.QueryableContextType.html\" title=\"trait swipl::context::QueryableContextType\">QueryableContextType</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.73.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../dict/struct.DictIterator.html\" title=\"struct swipl::dict::DictIterator\">DictIterator</a>&lt;'a, 'b, T&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.73.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"enum\" href=\"../dict/enum.Key.html\" title=\"enum swipl::dict::Key\">Key</a>, <a class=\"struct\" href=\"../term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'a&gt;);</span>","TermListIterator<'b, 'a, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.TermListIterator.html\" title=\"struct swipl::context::TermListIterator\">TermListIterator</a>&lt;'a, 'b, CT&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'a, 'b, CT: <a class=\"trait\" href=\"trait.QueryableContextType.html\" title=\"trait swipl::context::QueryableContextType\">QueryableContextType</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.73.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.TermListIterator.html\" title=\"struct swipl::context::TermListIterator\">TermListIterator</a>&lt;'a, 'b, CT&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.73.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"../term/struct.Term.html\" title=\"struct swipl::term::Term\">Term</a>&lt;'a&gt;;</span>","WritablePrologStream<'b>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../stream/struct.WritablePrologStream.html\" title=\"struct swipl::stream::WritablePrologStream\">WritablePrologStream</a>&lt;'a&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.73.0/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"../stream/struct.WritablePrologStream.html\" title=\"struct swipl::stream::WritablePrologStream\">WritablePrologStream</a>&lt;'a&gt;</span>"}</script></section></div></main></body></html>